* What are they? - Common architecture approaches, observed and applicated across languages. Sometimes you are using such, even without realizing that.
* `SOLID` desing principle - Creational / Structural / Behavioral - Gamma categorzation - frequently reffered in design principles
    * `Single responsibility principle` - it tells a class has single primary responsibility. Journal class have to any add/remove entries and can return count
    * `Open Close principle` - open for extension, closed for modification - not having different methods in a class that filter but write modular separate classes for filter. Example includes separate of concern.
    * `Liskov substitution principle` - if some method/function can take some base type it should also equally be able to take a derived type
    * `Interface segregaton` - class behaves as interface definition, no construction. Segragate into multiple interfaces - Machine -> Printer, Scanner, Photocopier
    * `Dependency Inversion principle` - no connection with dependency injection. Defines relationships that should have btw low and high level modules. High lever Research should not depend on low level like Relationships
* `Creational`
    * `Builder` - more complicated object with complexity, privdes API constructing objects step by step for object with more init properties - classes `Tag` and `HTMLBulder` 
    * `Factory` - Initializer is not descriptive, wholesale obj creation, factory method is static method letting you create an object - `Point` and `PointFactory`
    * `Prototype` - iterate exisiting design and improve on them, clone the ptototype and customize it. It is by description a partially or fully initilizaed object that you copy and make use of - `John` is prototype for `Jane` objects both `Person` witn `Address` w or without deep copying props examples.
    * `Singleton` - one instance - database, object factory, construcor call is expective
* `Structural` - relationships between objects
    * `Adapter` - adapt interface given to anoher one that we need (ie electrical device) - `Point/Line` to `LinesToPointAdapter`. Or XML to JSON adapter
    * `Bridge` - we have base class ThreadScheduler with two types and run on two env linux/windows and generate 2x2 classes - instead base class and extend to platform and type sub classes. In other words amechanism that decouples an interface from implementation - way of connecting two hieararchys of objects together.
    * `Composite` - Composition lets us make compound objects - collections of things, ie shape group of several different shapes. Let us treat both single and composite objects uniformly ie Foo and array of Foos having same API. Example with `GraphicObject` as sinlge obj or group of such. The composite pattern brings flexibility in an application and makes sure the group of objects behaves in the same way as an individual object.
    * `Decorator` - add addiotional behaviors without modify or inherit the class. It is reference to the object without inherit. Ie wrapper to underlying class without modifying it
    * `Facade` - exposing several components through single interface - house(electrical, sanitation, floor layers)
    * `Flyweight` - space optimization - save memory by storing externally the data associated with similar objects. Avoid redundency when store data. Like xample of lists of first and last names with index and create names based on them
    * `Proxy` - an interface to access particular resource. A class that functions as an interface to a prticular resource.
* `Behavioral` - handle communications between objects
    * `Chain of responsibility` - unethical behavior of employee who takes the blame? Employee/Manager/CEO. A chain of components who all get a chance to process a command or query, optionally having default processing implementation and an ability to terminate the process chain.
    * `Command` - Variable assignment - cannot undo assignment, cannot directly serialize. We want an object that represent an operation - person should be able to change age. Uses - gui commands, multi level undo/redo...An object which represent an instruction to perform a particular action, contains all the info necessary for the action to be taken
    * `Interpreter` - textual input needs to be processed (programming language ie / Regex / numeric expressions 3+4/5). A component that processes structured text data. Does so by turning it into separate lexical tokens (lexing) and then interpreting sequences of said tokens (parsing)
    * `Iterator` - traversal of data structure.Iterator is a class that facilitates the traversal. Symbol.iterator is member of class that returms iterator object with function called next() returned the current value and done flag for status. Iterator itself is not iterable.
    * `Mediator` - components may go in and out of system - makes no sense for them to have direct reference - central component for communication
    * `Memento` - Object in system goes through changes - bank account (deposits/withdrawals).Record every change and teach to undo or save snapshots of the system (memento). Ie A token/handler representing the system state. lets us roll back to the state when the token was generated. May or mey not directly expose state info
    * `Observer` - need to be informed when things happen, watch when object does something, external event outside the system happens. Option to unsubscribe. The entity   vs `observer`
    * `State` - ordinary  telephone - depends what you can do - pick up / make a call. Changes are explicit or they can be response to event. Object behavior is determined by its state. Transitions from one to another. A formalized construct which manages states and transitions is called state machine.
    * `Strategy` - many algorythms can be decompress into high and low level parts - making hot beverage and put teabag into water. Reuse the high level to make cofee ie.
    * `Template` - similar to strategy method - decompsed algos into common parts - through use of empty abstract members(empty) - inherit class and override members. Ie define skeleton of algo(main thins is defined in main class) with concrete implementations defined in subclasses
    * `Visitor` - need to defined new operation on entire class hierarchy. Document printable to different formats - need access to the non common aspects of classes. Create external component knows how to navigate entire structure. ie component (visitor) knows how to traverse a data structure composed of possibly related types.
    * 